#include "SourceTokenizer.hpp"

// constructor
SourceTokenizer::SourceTokenizer(const std::string& _source) {
        source = _source;
}

// destructor
SourceTokenizer::~SourceTokenizer() {}

bool SourceTokenizer::isNotEndOfSource(){
    return cursor < source.length();
}

// method to tokenize a program / query std::string
// it currently tokenizes the std::string into a vector of 
// words (any alphanumeric sequence of characters starting with a letter, e.g., "num1"),
// numbers (any numeric sequence of characters, e.g., "1001"),
// and punctuations (any other non-space characters, e.g., "=", ";", "{", "}").
// it should be extended as needed to handle additional SIMPLE / PQL grammar rules.
void SourceTokenizer::tokenize(std::vector<std::string>& tokens) {
	tokens.clear();
	std::string token;
	
	while (isNotEndOfSource()) {
		char ch = source.at(cursor);
		
		if (isdigit(ch)) { // scan for a numeric sequence
			token.push_back(ch);
            cursor++;

			while (isNotEndOfSource()) {
				ch = source.at(cursor);
				if (isdigit(ch)) {
					token.push_back(ch);
                    cursor++;
				}
				else {
					break;
				}
			}

			tokens.push_back(token);
			token.clear();
		}
		else if (isalpha(ch)) { // scan for an alphanumeric sequence starting with a letter 
			token.push_back(ch);
            cursor++;
			while (isNotEndOfSource()) {
				ch = source.at(cursor);
				if (isalpha(ch) || isdigit(ch)) {
					token.push_back(ch);
                    cursor++;
				}
				else {
					break;
				}
			}

			tokens.push_back(token);
			token.clear();
		}
		else if (!isspace(ch)) { // scan for punctuations
			token.push_back(ch);
            cursor++;

			tokens.push_back(token);
			token.clear();
		}
		else {
            cursor++;
		}
	}
}
